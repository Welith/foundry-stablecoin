// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {HelperConfig} from "../../../script/HelperConfig.s.sol";
import {ERC20DecimalsMock} from "@openzeppelin/contracts/mocks/ERC20DecimalsMock.sol";
import {DSCEngine} from "../../../src/DSCEngine.sol";
import {DeployDSCEngine} from "../../../script/DeployDSCEngine.s.sol";
import {DecentralizedStableCoin} from "../../../src/DecentralizedStableCoin.sol";
import {ERC20DecimalsMock} from "@openzeppelin/contracts/mocks/ERC20DecimalsMock.sol";
import {MockV3Aggregator} from "../../mocks/MockV3Aggregator.sol";

// Create collateral tokens with actual demical values
// Test liquidation with these decimal values

contract ExploitCollateralDecimalTest is Test {
    DSCEngine private dsce;
    DecentralizedStableCoin private dsc;
    HelperConfig private helperConfig;

    uint256 private constant STARTING_BALANCE = 10 ether;
    uint256 private constant LIQUIDATION_PRECISION = 100;
    uint256 private constant LIQUIDATION_THRESHOLD = 50;
    uint256 private constant LIQUIDATION_BONUS = 10;

    address private wethUsdPriceFeed;
    address private wbtcUsdPriceFeed;
    address private weth;
    address private wbtc;
    uint256 private wethDecimals;
    uint256 private wbtcDecimals;
    uint256 private feedDecimals;

    address private _USER = makeAddr("user");
    address private _EXPLOITER = makeAddr("exploiter");

    function setUp() public {
        DeployDSCEngine engineDeployer = new DeployDSCEngine();
        (dsc, dsce, helperConfig) = engineDeployer.run();

        (wethUsdPriceFeed, wbtcUsdPriceFeed, weth, wbtc,) = helperConfig.activeConfig();

        ERC20DecimalsMock(weth).mint(_USER, STARTING_BALANCE);
        ERC20DecimalsMock(wbtc).mint(_USER, STARTING_BALANCE);
        ERC20DecimalsMock(weth).mint(_EXPLOITER, STARTING_BALANCE);

        wethDecimals = ERC20DecimalsMock(weth).decimals();
        wbtcDecimals = ERC20DecimalsMock(wbtc).decimals();
        feedDecimals = helperConfig.DECIMALS();
    }

    function testCollateralDecimalExploit() public {
        // We start loading the user
        vm.startPrank(_USER);
        uint256 wethAmount = 1 * 10 ** wethDecimals; // 1 WETH
        uint256 expectedUsdValueWeth =
            (wethAmount * uint256(MockV3Aggregator(wethUsdPriceFeed).getLatestAnswer())) / (10 ** feedDecimals);
        uint256 maxDscToMintFronEth = (expectedUsdValueWeth * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;
        console.log("expected USD in wei value of WETH:", expectedUsdValueWeth);
        console.log("maxDscToMintFronEth: ", maxDscToMintFronEth);
        ERC20DecimalsMock(weth).approve(address(dsce), wethAmount);
        dsce.depositCollateralAndMintDsc(weth, wethAmount, maxDscToMintFronEth);
        assertEq(dsc.balanceOf(_USER), maxDscToMintFronEth);
        vm.stopPrank();

        // Lets test USD value from contract and token value from USD
        assertEq(dsce.getUsdValue(weth, wethAmount), 2000 ether);
        assertEq(dsce.getTokenAmountFromUsd(weth, expectedUsdValueWeth), 1 ether);

        // We load the user with WBTC
        vm.startPrank(_USER);
        uint256 wbtcAmount = 1 * 10 ** wbtcDecimals; // 1 WBTC
        uint256 expectedUsdValueWbtc = dsce.getUsdValue(wbtc, wbtcAmount); // 0.0000030000$ instead of 30000$
        uint256 maxDscToMintFromBtc = (expectedUsdValueWbtc * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;
        console.log("maxDscToMintFromBtc: ", maxDscToMintFromBtc);
        console.log("expected USD in wei value of WBTC:", expectedUsdValueWbtc);
        ERC20DecimalsMock(wbtc).approve(address(dsce), wbtcAmount);
        dsce.depositCollateralAndMintDsc(wbtc, wbtcAmount, maxDscToMintFromBtc);
        assertEq(dsc.balanceOf(_USER), maxDscToMintFromBtc + maxDscToMintFronEth);
        console.log("User DSC balance: ", dsc.balanceOf(_USER));
        assertEq(dsce.getUserCollateral(_USER, wbtc), 1 * 10 ** wbtcDecimals);
        vm.stopPrank();

        assertEq(dsce.getUsdValue(wbtc, wbtcAmount), 30000 ether); // 0.0000030000$ instead of 30000$

        // Add DSC to the exploiter
        vm.startPrank(_EXPLOITER);
        ERC20DecimalsMock(weth).approve(address(dsce), wethAmount);
        dsce.depositCollateralAndMintDsc(weth, wethAmount, maxDscToMintFronEth);
        assertEq(dsc.balanceOf(_EXPLOITER), maxDscToMintFronEth);
        assertEq(dsce.getUserCollateral(_EXPLOITER, weth), wethAmount);
        vm.stopPrank();

        // Changing the price feed
        MockV3Aggregator(wbtcUsdPriceFeed).updateAnswer(int256(29_999 * 10 ** feedDecimals));
        uint256 newValueWbtcUsd = dsce.getUsdValue(wbtc, wbtcAmount);
        console.log("User new WBTC value in USD: ", newValueWbtcUsd);
        console.log("User Health Factor: ", dsce.getHealthFactor(_USER));
        assert(dsce.getHealthFactor(_USER) < dsce.getMinHealthFactor());

        // Liquidating the user
        vm.startPrank(_EXPLOITER);
        uint256 debtToPayInWbtc = 15000 ether; // 15 000 DSC debt for 30000$ WBTC
        console.log("debtToPayInWbtc: ", debtToPayInWbtc);
        dsc.approve(address(dsce), newValueWbtcUsd);
        vm.expectRevert("ERC20: transfer amount exceeds balance");
        dsce.liquidate(wbtc, _USER, debtToPayInWbtc); // After my change the exploiter cannot liquidate the user, as he won't have enough DSC to covet the WBTC debt
        vm.stopPrank();

        // uint256 err = 0.0001 ether; // 0.01% allowable relative error to account for rounding
        // assertApproxEqRel(ERC20DecimalsMock(wbtc).balanceOf(_EXPLOITER), wbtcAmount, err);
        // assertApproxEqRel(dsc.balanceOf(_EXPLOITER), maxDscToMintFronEth, err);
    }
}
